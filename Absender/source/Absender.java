/* autogenerated by Processing revision 1296 on 2026-01-15 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Absender extends PApplet {




PImage image;


public void setup(){
  /* size commented out by preprocessor */;
  selectInput("Bilddatei auswählen", "fileSelected");
}


public void draw(){}


public void fileSelected(File selection) {
  
  if (selection != null){
    image = loadImage(selection.getAbsolutePath());
    s = new Signal(image, 0);
    saveBytes("toneSignal.wav", s.exportWav());
    s.updateSample(this);
    println("DONE");
    s.sample.loop();
  }
  else exit();
}


// Setzt ein Tongemisch nach den gegebenen Parametern zusammen
public float[] inverseFourier(int[] amplitudes, int sampleRate){
  
  float[] result = new float[sampleRate];
  
  // Generiere alle Töne
  for (int f = 0; f < amplitudes.length; f++){
    
    // Generiere einen zufälligen Phasenwinkel
    float phi = random(TAU);
    
    // Taste die Sinuswelle ab
    for (int s = 0; s < sampleRate; s++){
      result[s] += amplitudes[f] * sin((s * (f+1) * TAU) / sampleRate + phi);
    }
  }
  
  // Anpassen der Lautstärke durch Skalieren
  result = normalizeWave(result);
  
  return result;
}


// "Normalisiert" den Wertebereich einer Frequenzsumme auf das Intervall [-1;1]
public float[] normalizeWave(float[] samples){
  
  float maxVal = 0;
  
  // Größten Ausschlag ermitteln
  for (float f : samples) maxVal = max(abs(f), maxVal);
  
  // Alle Daten als Anteil daran ausrichten
  for (int i = 0; i < samples.length; i++) samples[i] /= maxVal;
  
  return samples;
}
Signal s;


class Signal {
  
  
  int[] freqs;
  int[] amps;
  
  float[] samples;
  AudioSample sample;
  
  int sampleRate = 44100;
  int blockAlign = 2;
  
  int colorMode;
  
  
  Signal(PImage img, int mode){
    
    // Laden des Bildes
    img.resize(120, 160);
    colorMode = mode;
    
    // Amplituden-Array
    amps = new int[img.width * img.height + 1];
    
    // Definieren der Basis-Frequenz
    amps[0] = 255;
    
    // Arrays je nach Farbkanal
    for (int i = 1; i < amps.length; i++){
      
      switch (colorMode){
        case 0:
        amps[i] = (int) brightness(img.pixels[i - 1]);
        break;
        
        case 1:
        amps[i] = (int) red(img.pixels[i - 1]);
        break;
        
        case 2:
        amps[i] = (int) green(img.pixels[i - 1]);
        break;
        
        case 3:
        amps[i] = (int) blue(img.pixels[i - 1]);
        break;
      }
    }
    
    samples = inverseFourier(amps, sampleRate);
  }
  
  
  // Erstellen des AudioSamples
  public void updateSample(PApplet sketchObject){
    sample = new AudioSample(sketchObject, samples, sampleRate);
  }
  
  
  // Abspeichern der .wav-Datei
  public byte[] exportWav(){
    
    byte[] bytes = new byte[samples.length * blockAlign + 44];
    
    // RIFF chunk descriptor
    bytes = insert(bytes, stringToBE("RIFF"), 0);
    bytes = insert(bytes, intToLE(bytes.length - 8, 4), 4);
    bytes = insert(bytes, stringToBE("WAVE"), 8);
    
    // format subchunk
    bytes = insert(bytes, stringToBE("fmt "), 12);
    bytes = insert(bytes, intToLE(16, 4), 16);
    bytes = insert(bytes, intToLE(1, 2), 20);
    bytes = insert(bytes, intToLE(1, 2), 22);
    bytes = insert(bytes, intToLE(sampleRate, 4), 24);
    bytes = insert(bytes, intToLE(sampleRate * blockAlign, 4), 28);
    bytes = insert(bytes, intToLE(blockAlign, 2), 32);
    bytes = insert(bytes, intToLE(blockAlign * 8, 2), 34);
    
    // data subchunk
    bytes = insert(bytes, stringToBE("data"), 36);
    bytes = insert(bytes, intToLE(bytes.length - 44, 4), 40);
    
    for (int i = 0; i < samples.length; i++){
      
      // Beachte -1 in pow(): Die Range beinhaltet sowohl den positiven als auch negativen Zahlenbereich
      int sampleVal = PApplet.parseInt(samples[i] * pow(2, (8 * blockAlign) - 1));
      bytes = insert(bytes, intToLE(sampleVal, blockAlign), 44 + i * blockAlign);
    }
    
    return bytes;
  }
}


// Fügt ein byte-Array aus einem String zusammen (big endian)
public byte[] stringToBE(String s){
  
  byte[] block = new byte[s.length()];
  
  for (int i = 0; i < block.length; i++){
    block[i] = PApplet.parseByte(s.charAt(i));
  }
  
  return block;
}


// Fügt einen Integer in ein Byte-Array ein (little endian)
public byte[] intToLE(int i, int byteAmount){
  
  byte[] block = new byte[byteAmount];
  
  for (int b = byteAmount - 1; b >= 0; b--){
    int byteVal = floor(i / pow(2, 8 * b));
    block[b] = PApplet.parseByte(byteVal);
    i -= byteVal * pow(2, 8 * b);
  }
  
  return block;
}


// Fügt einen Byte-Block in ein Byte-Array ein
public byte[] insert(byte[] origin, byte[] block, int start){
  
  for (int i = 0; i < block.length; i++){
    origin[start + i] = block[i];
  }
  
  return origin;
}


  public void settings() { size(400, 400); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Absender" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
