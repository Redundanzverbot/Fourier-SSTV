/* autogenerated by Processing revision 1296 on 2025-05-31 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Sender extends PApplet {



PImage img;
Signal sig;

float deltaX;

int imgWidth = 160;
int imgHeight = 120;

boolean playing = true;


public void setup(){
  
  /* size commented out by preprocessor */;
  
  background(0);
  
  deltaX = (width * 0.5f - 75) / imgWidth;
  
  buttons[0] = (new Button(0));
  buttons[1] = (new Button(1, color(0)));
  buttons[2] = (new Button(2, color(255, 0, 0)));
  buttons[3] = (new Button(3, color(0, 255, 0)));
  buttons[4] = (new Button(4, color(0, 0, 255)));
  
  // Geräusch laden
  //s = new Signal("image.png");
  
  // Geräusch abspielen
  //s.updateSample(this);
  //s.sample.loop();
  
  // Speichern der .wav-Datei
  //saveBytes("toneSignal.wav", s.exportWav());
  
  // Anzeigen einer Audiowelle
  //s.show();
}


public void draw(){

  background(200);
  textAlign(CENTER, CENTER);
  textSize(60);
  noStroke();
  
  buttons[0].show();
  
  // Bild-Kästchen
  fill(255);
  rect(50, 50, width / 2.0f - 75, 120 * deltaX);
    
  if (img != null){
    image(img, 80, 80, width / 2.0f - 135, imgHeight * deltaX - 60);
    for (int i = 1; i < 5; i++){
      buttons[i].show();
    }
  }
  
  else {
    fill(200);
    text("Select", 50 + (width / 2.0f - 75) * 0.5f, 50 + imgHeight * 0.5f * deltaX);
  }
  
  // Wellen-Kästchen
  fill(255);
  rect(width / 2.0f + 25, 50, width / 2.0f - 75, imgHeight * deltaX);
  stroke(200);
  strokeWeight(3);
  
  line(width / 2.0f + 25, 50 + imgHeight * 0.5f * deltaX, width - 50, 50 + imgHeight * 0.5f * deltaX);
  if (sig != null){
    sig.show();
  }
  
  noStroke();
  fill(255);
  if (sig != null){
    if (playing){
      rect(width - 200, height - 200, 150, 150);
    } else {
      triangle(width - 200, height - 200, width - 50, height - 125, width - 200, height - 50);
    }
  }
}


public void mousePressed(){
  
  if (mouseX >= 50 && mouseY >= 50 && mouseX <= width * 0.5f - 25 && mouseY <= 50 + imgHeight * deltaX){
    selectInput("Bilddatei auswählen", "fileSelected");
  }
  
  if (mouseY < height - 200){
    return;
  }
  
  if (dist(mouseX, mouseY, width - 100, height - 100) <= 150){
    if (playing) sig.sample.stop();
    else sig.sample.loop();
    playing = !playing;
  }
  
  // Kalibrierung
  if (buttons[0].isPressed(mouseX)){
    if (sig != null) sig.sample.stop();
    sig = new Signal(loadImage("white.png"), 0);
    sig.updateSample(this);
    sig.sample.loop();
    playing = true;
    saveBytes("toneSignal.wav", sig.exportWav());
    return;
  }
  
  // Farbkanal
  if (img == null){
    return;
  }
  
  for (int i = 1; i < 5; i++){
    if (buttons[i].isPressed(mouseX)){
      if (sig != null) sig.sample.stop();
      sig = new Signal(img, i - 1);
      sig.updateSample(this);
      sig.sample.loop();
      playing = true;
      saveBytes("toneSignal.wav", sig.exportWav());
      return;
    }
  }
}


public void fileSelected(File selection) {
  
  if (selection != null){
    img = loadImage(selection.getAbsolutePath());
  }
}


// iDFT eines Tongemischs
public float[] inverseFourier(int[] frequencies, int[] amplitudes, int sampleRate){
  
  float[] result = new float[sampleRate];
  
  // Generiere alle Töne
  for (int f = 0; f < frequencies.length; f++){
  
  // Addiere alle Töne zusammen
  float[] freq = generateSequence(frequencies[f], amplitudes[f], sampleRate);
    for (int i = 0; i < sampleRate; i++){
      result[i] += freq[i];
    }
  }
  
  // Anpassen der Lautstärke durch gemeinsamen Skalieren
  result = normalizeWave(result);
  
  return result;
}


// Beschränkt den Zahlenbereich einer Frequenzsumme auf das Intervall [-1.0;1.0]
public float[] normalizeWave(float[] samples){
  
  float max = 0;
  
  for (float f : samples){
    if (abs(f) > max){
      max = abs(f);
    }
  }
  
  for (int i = 0; i < samples.length; i++){
    samples[i] = samples[i] / max;
  }
  
  return samples;
}


// iDFT eines einzelnen Tons
public float[] generateSequence(int f, int a, int N){
  
  float[] result = new float[N];
  float phi = random(TAU);

  // Generiert eine Sinuswelle mit bestimmter Frequenz
  for (int t = 0; t < N; t++){
    result[t] = a * sin((t * f * TAU) / N + phi);
  }

  return result;
}
Button[] buttons = new Button[5];

float buttonWidth = 200;


class Button{
  
  int index;
  int c;
  float pos;
  int[] samples;
  float[] amplitudes;
  
  
  Button(int i, int col){
    c = col;
    index = i;
    pos = (i + 1) * 50 + i * buttonWidth;
  }
  
  
  Button(int i){
    index = i;
    pos = (i + 1) * 50 + i * buttonWidth;
  }
  
  
  public boolean isPressed(int mx){
    return mx >= pos && mx <= pos + buttonWidth;
  }
  
  
  public void show(){
    
    if (index == 0){
      stroke(255, 255, 255);
      strokeWeight(5);
      noFill();
      rect(pos, height - 200, buttonWidth, 210, 30, 30, 0, 0);
      
      fill(255);
      noStroke();
      textSize(100);
      textAlign(CENTER, CENTER);
      text("K", pos + buttonWidth * 0.5f, height - 100);
    }
    
    else {
      fill(c);
      rect(pos, height - 200, buttonWidth, 200, 30, 30, 0, 0);
    }
    
    if (samples != null){
      stroke(0);
      strokeWeight(5);
      fill(255);
      circle(width - 250, pos + buttonWidth * 0.5f, 35);
    }
  }
}
float zoom = 200;


class Signal {
  
  int[] freqs;
  int[] amps;
  
  float[] samples;
  AudioSample sample;
  
  int sampleRate = 44100;
  int blockAlign = 2;
  
  int colorMode;
  
  
  Signal(PImage image, int mode){
    
    image.resize(160, 120);
    colorMode = mode;
    
    // Anlegen der Arrays
    freqs = new int[image.width * image.height + 1];
    amps = new int[image.width * image.height + 1];
    
    // Definieren der Basis-Frequenz
    freqs[0] = 1;
    amps[0] = 255;
    
    // Arrays bestücken
    for (int i = 1; i < amps.length; i++){
      freqs[i] = i + 1;
      
      switch (colorMode){
        case 0:
        amps[i] = (int) brightness(image.pixels[i - 1]);
        break;
        
        case 1:
        amps[i] = (int) red(image.pixels[i - 1]);
        break;
        
        case 2:
        amps[i] = (int) green(image.pixels[i - 1]);
        break;
        
        case 3:
        amps[i] = (int) blue(image.pixels[i - 1]);
        break;
      }
    }
    
    samples = inverseFourier(freqs, amps, sampleRate);
  }
  
  
  // Debug-Konstruktor
  Signal(int[] frequencies, int[] amplitudes, int sr){
    
    freqs = frequencies;
    sampleRate = sr;
    amps = amplitudes;
    
    samples = inverseFourier(freqs, amps, sampleRate);
  }
  
  
  // Erstellen des AudioSamples
  public void updateSample(PApplet sketchObject){
    sample = new AudioSample(sketchObject, samples, sampleRate);
  }
  
  
  // Abspeichern der .wav-Datei
  public byte[] exportWav(){
    
    byte[] bytes = new byte[samples.length * blockAlign + 44];
    
    // RIFF chunk descriptor
    bytes = insert(bytes, stringToBE("RIFF"), 0);
    bytes = insert(bytes, intToLE(bytes.length - 8, 4), 4);
    bytes = insert(bytes, stringToBE("WAVE"), 8);
    
    // format subchunk
    bytes = insert(bytes, stringToBE("fmt "), 12);
    bytes = insert(bytes, intToLE(16, 4), 16);
    bytes = insert(bytes, intToLE(1, 2), 20);
    bytes = insert(bytes, intToLE(1, 2), 22);
    bytes = insert(bytes, intToLE(sampleRate, 4), 24);
    bytes = insert(bytes, intToLE(sampleRate * blockAlign, 4), 28);
    bytes = insert(bytes, intToLE(blockAlign, 2), 32);
    bytes = insert(bytes, intToLE(blockAlign * 8, 2), 34);
    
    // data subchunk
    bytes = insert(bytes, stringToBE("data"), 36);
    bytes = insert(bytes, intToLE(bytes.length - 44, 4), 40);
    
    for (int i = 0; i < samples.length; i++){
      // Beachte 7: Die Range beinhaltet sowohl den positiven als auch negativen Zahlenbereich
      int sampleVal = PApplet.parseInt(samples[i] * pow(2, (8 * blockAlign) - 1));
      bytes = insert(bytes, intToLE(sampleVal, blockAlign), 44 + i * blockAlign);
    }
    
    return bytes;
  }
  
  
  // Anzeigen der Audiowelle
  public void show(){
    
    int amount = width / 2 - 75;
    int skip = samples.length / amount;
    float maxY = (float) imgHeight * 0.5f * deltaX;
    
    stroke(200);
    strokeWeight(2);
    pushMatrix();
    translate(width / 2.0f + 25, 50 + maxY);
    
    line(0, 0, width, 0);
    stroke(buttons[colorMode + 1].c);
    
    for (int i = 0; i < amount - 1; i++){
      line(i, -samples[i * skip] * maxY, i + 1, -samples[(i + 1) * skip] * maxY);
    }
    popMatrix();
  }
}
// Fügt ein byte-Array aus einem String zusammen (big endian)
public byte[] stringToBE(String s){
  
  byte[] block = new byte[s.length()];
  
  for (int i = 0; i < block.length; i++){
    block[i] = PApplet.parseByte(s.charAt(i));
  }
  
  return block;
}


// Fügt einen Integer in ein Byte-Array ein (little endian)
public byte[] intToLE(int i, int byteAmount){
  
  byte[] block = new byte[byteAmount];
  
  for (int b = byteAmount - 1; b >= 0; b--){
    int byteVal = floor(i / pow(2, 8 * b));
    block[b] = PApplet.parseByte(byteVal);
    i -= byteVal * pow(2, 8 * b);
  }
  
  return block;
}


// Fügt einen Byte-Block in ein Byte-Array ein
public byte[] insert(byte[] origin, byte[] block, int start){
  
  for (int i = 0; i < block.length; i++){
    origin[start + i] = block[i];
  }
  
  return origin;
}


  public void settings() { size(1600, 900); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Sender" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
