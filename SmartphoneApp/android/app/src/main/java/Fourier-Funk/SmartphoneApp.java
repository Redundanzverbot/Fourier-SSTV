package Fourier-Funk;

/* autogenerated by Processing revision 1296 on 2026-01-15 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import android.media.AudioRecord;
import android.media.AudioFormat;
import android.media.MediaRecorder;
import android.os.Environment;
import java.io.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class SmartphoneApp extends PApplet {







AudioRecord recorder;

int bufferSize;
boolean isRecording = false;

int imgWidth = 120;
int imgHeight = 160;
int res;


public void setup(){
  
  /* size commented out by preprocessor */;
  orientation(PORTRAIT);
  
  // App benötigt Zugriff auf das Mikrofon
  requestPermission("android.permission.RECORD_AUDIO");
  
  bufferSize = AudioRecord.getMinBufferSize(44100, AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT);
  recorder = new AudioRecord(MediaRecorder.AudioSource.MIC, 44100, AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT, bufferSize);
  
  // Buttons erstellen
  res = width / imgWidth;
  bWidth = (width - 6 * 30) / 5;
  
  buttons[0] = (new Button(0, color(255, 255, 255)));
  buttons[1] = (new Button(1, color(255, 255, 255)));
  buttons[2] = (new Button(2, color(255,   0,   0)));
  buttons[3] = (new Button(3, color(  0, 255,   0)));
  buttons[4] = (new Button(4, color(  0,   0, 255)));
  
  // Buttons anzeigen
  background(0);
  noStroke();
  fill(255);
  rect(0, 0, width, res*imgHeight);
  textSize(80);
  textAlign(CENTER, CENTER);
  for (Button b : buttons) b.show();
}


public void draw(){}


public void mousePressed(){
  
  if (recording != null || mouseY < height-bHeight) return;
  
  // Teste, ob ein Button gedrückt wurde
  for (int i = 0; i < 5; i++){
    if (!buttons[i].isPressed(mouseX)) continue;
    
    recording = buttons[i];
    startRecording();
    break;
  }
}


public void showImage(){
  
  noStroke();
  
  // Bestimme den Farbmodus
  int colorMode = 0;
  if (buttons[2].samples != null || buttons[3].samples != null || buttons[4].samples != null) colorMode = 1;
  else if (buttons[0].samples == null && buttons[1].samples == null) return;
  
  // Speichere, ob kalibriert wurde
  boolean calibration = buttons[0].amplitudes != null;
  
  // Zeige alle Pixel an
  for (int i = 0; i < imgWidth * imgHeight; i++){
    
    // Graustufen
    if (colorMode == 0){
      float val = buttons[1].samples == null ? buttons[0].amplitudes[i]
                                             : calibration ? buttons[1].amplitudes[i] / buttons[0].amplitudes[i]
                                                           : buttons[1].amplitudes[i];
      fill(val*255);
    }

    // In Farbe
    else {
      float[] c = new float[3];
      
      // Werte festlegen
      for (int j = 0; j < 3; j++){
        if (buttons[j + 2].amplitudes == null) continue;
          c[j] = calibration ? buttons[j + 2].amplitudes[i] / buttons[0].amplitudes[i]
                             : buttons[j + 2].amplitudes[i];
      }
      
      fill(c[0]*255, c[1]*255, c[2]*255);
    }
    
    rect(res * (i % imgWidth), res * (floor(i / imgWidth)), res, res);
  }
}


// Aufnahme beginnen
public void startRecording() {
  
  background(0);
  fill(255);
  rect(0, 0, width, res*imgHeight);
  for (Button b : buttons) b.show();
  
  if (recorder.getState() != AudioRecord.STATE_INITIALIZED) {
    text("Fehlende Berechtigung", .5f*width, height - 600);
    recording = null;
    return;
  }
  
  // Auf einem zweiten Kern Tonspur aufnehmen
  recorder.startRecording();
  new Thread(new Runnable() {public void run() {collectAudioData();}}).start();
  
  isRecording = true;
}


// Aufnahme beenden
public void stopRecording() {
  
  isRecording = false;
  if (recorder.getRecordingState() == AudioRecord.RECORDSTATE_RECORDING) {
    recorder.stop();
  }
  
  recording.processAudioData();
  recording = null;
  
  background(0);
  fill(255);
  rect(0, 0, width, res*imgHeight);
  for (Button b : buttons) b.show();
  
  showImage();
}


// Methode zum Aufnehmen, wird in einem zweiten Kern ausgeführt
public void collectAudioData() {
  
  byte[] audioData = new byte[bufferSize];     // Liest die Rohdaten eines Durchgangs aus
  int[] recordSamples = new int[44100];        // Speichert die Aufnahme
  int counter = 0;                             // Zählt die Anzahl der gesammelten Samples
  int startTime = millis();

  while (isRecording) {
    
    // Rohdaten auslesen
    int read = recorder.read(audioData, 0, bufferSize);
    
    // Überspringen, falls keine Daten vorhanden. Außerdem werden 500 ms gewartet, um Interferenzen zu verringern
    if (read == 0 || millis() - startTime < 500){
      continue;
    }
    
    // Konvertiere Rohdaten in Ganzzahlen (2-Byte LE)
    int[] samples = new int[audioData.length / 2];

    for (int i = 0; i < audioData.length; i+=2){
      int b1 = audioData[i];
      int b2 = audioData[i + 1] * PApplet.parseInt(pow(2, 8));
      samples[i / 2] = b1 + b2;
    }
    
    for (int i = 0; i < samples.length; i++){
      
      // Beenden, sobald alle Samples gesammelt wurden
      if (counter >= recordSamples.length){
        recording.samples = recordSamples;
        stopRecording();
        return;
      }
      
      // Hinzufügen eines Samples
      recordSamples[counter] = samples[i];
      counter++;
    }
  }
}
Button[] buttons = new Button[5];
Button recording;
int bWidth;
int bHeight = 400;

float[] gaussWeights = {0.26f, 0.21f, 0.11f, 0.04f, 0.01f};


class Button{
  
  
  int index;
  int c;
  float pos;
  
  int[] samples;
  float[] amplitudes;
  
  
  Button(int i, int col){
    index = i;
    c = col;
    pos = (i + 1) * 30 + i * bWidth;
  }
  
  
  // Ausführung nachdem alle Samples gesammelt wurden
  public void processAudioData(){
    
    background(0);
    fill(255);
    rect(0, 0, width, res*imgHeight);
    for (Button b : buttons) b.show();
    
    amplitudes = new float[imgWidth * imgHeight];
    
    // Auslesen der Basis-Frequenz 1 Hertz
    float baseValue = dft(1);
    
    // Skalieren der Amplituden-Werte
    for (int i = 2; i <= amplitudes.length + 1; i++){
    
      // Der Farbwert wird als Prozentwert an der Basisfrequenz interpretiert
      float val = dft(i);
      val /= baseValue;
      amplitudes[i - 2] = val;
      
      fill(val * red(c), val * green(c), val * blue(c));
      rect(res * (i % imgWidth), res * (floor(i / imgWidth)), res, res);
    }
    
    // Blurre die Kalibrierung
    if (index == 0) amplitudes = gaussBlur(amplitudes);
  }
  
  
  // Diskrete Fourier-Transformation
  public float dft(int xi){
    
    int N = samples.length;
    float[] avg = new float[] {0, 0};
    
    // Komplexe Summe bilden
    for (int n = 0; n < N; n++){
      avg[0] += samples[n] * cos(-xi * n * TAU / N); // Realteil
      avg[1] += samples[n] * sin(-xi * n * TAU / N); // Imaginärteil
    }
    
    return dist(0, 0, avg[0], avg[1]);
  }
  
  
  public float[] gaussBlur(float[] array){
    
    float[] result = new float[array.length];
    
    for (int i = 4; i < array.length - 4; i++){
      float sum = 0;
      for (int j = -4; j <= 4; j++){
        sum += array[i + j] * gaussWeights[abs(j)];
      }
      result[i] = sum;
    }
    
    return result;
  }
  
  
  public boolean isPressed(int mx){
    return mx >= pos && mx <= pos + bWidth;
  }
  
  
  public void show(){
    
    // Rechteck zeichnen
    fill(c);
    rect(pos, height - bHeight - PApplet.parseInt(recording == this) * 100, bWidth, bHeight + 150, 50, 50, 0, 0);
    
    // "K" anzeigen
    if (index == 0) {
      fill(0);
      text("K", pos + .5f*bWidth, height - bHeight + 100);
    }
    
    fill(255);
    
    // Indikator, ob bereits geladen
    if (samples != null) circle(pos + .5f*bWidth, height - bHeight - 30, 35);
  }
}


  public void settings() { fullScreen(); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "SmartphoneApp" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
